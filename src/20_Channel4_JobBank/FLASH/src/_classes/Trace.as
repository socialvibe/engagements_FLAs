/** * Trace class * SWF inner output window *  * @author	emiker.pl * @version 0.1 */package {		import flash.display.GradientType;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.filters.BevelFilter;	import flash.geom.Matrix;	import flash.geom.Rectangle;	import flash.system.Capabilities;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.text.TextFormat;	import flash.ui.Keyboard;	import flash.display.DisplayObjectContainer;		public class Trace {				/**		 * Display object where output window will be creatad		 */		public static var root:DisplayObjectContainer;				/**		 * Indicates whether output will be enabled		 * Default: true		 */		public static var enabled:Boolean = true;				/**		 * Main text field font name		 * Default: 'Courier New'		 */		public static var fontName:String = 'Courier New';				/**		 * Main text field font size		 * Default: 12		 */		public static var fontSize:uint = 12;				/**		 * Window width		 * Default: 300		 */		public static var width:uint = 300;				/**		 * Window height		 * Default: 800		 */		public static var height:uint = 800;								/**		 * Main text field object		 */		private static var txt:TextField;				/**		 * Main text field side margin		 */		private static var txtSideMargin:int = 8;				/**		 * Main text field top margin		 */		private static var txtTopMargin:int = 35;				/**		 * Main text field bottom margin		 */		private static var txtBottomMargin:int = 10;				/**		 * Window & icons font name		 */		private static var windowFontName:String = 'Verdana';				/**		 * Window & icons font color		 */		private static var windowFontColor:Number = 0x666666;				/**		 * Window name (description)		 */		private static var windowName:String = 'Output';				/**		 * Scroller bar width		 */		private static var scrollerBarWidth:int = 18;				/**		 * Scroller bar min height		 */		private static var scrollerBarMinHeight:int = 50;				/**		 * Scroller bar object		 */		private static var scrollerBar:Sprite;				/**		 * Indicates whether scroller bar is currently dragged		 */		private static var isBarDragged:Boolean;				/**		 * Indicates whether output window have been already created		 */		private static var initiated:Boolean;				/**		 * Output window container object		 */		private static var container:Sprite;				/**		 * Close window button object		 */		private static var closeIcon:Sprite;				/**		 * Clear window button object		 */		private static var clearIcon:Sprite;						private static function objTrace( obj : *, level : int = 0 ) : void{        var tabs : String = "";        for ( var i : int = 0 ; i < level ; i++ ) {		tabs += "\t"		}		        for ( var prop : String in obj ){            Trace.add( tabs + "[" + prop + "] -> " + obj[ prop ] );            objTrace( obj[ prop ], level + 1 );        }    }					public static function obj( obj : * , level : int = 0 ) {				objTrace(obj, level);			}				/**		 * Adds text to output window		 * 		 * @param	text		 * @throws	Error		 */		public static function add(... args):void {									//if (root == null) throw new Error('Attribute \'root\' must be defined.');			//if (root == null) root = Stager.getStage();						if (! enabled) return;			var text:String = '';			var len:int = args.length;			if (len > 1) {				for (var i:int = 0; i < len; i++) {					trace(args[i]);					text += String(args[i]) + ' ';				}//end for			}else{				text = String(args);			}//end if						if (Capabilities.playerType == 'External') {				trace(text);				return;			}//end if									if (! initiated) init();			if (! container.visible) container.visible = true;			txt.appendText(text + '\n');			bringToFront();			txt.scrollV = txt.numLines - txt.bottomScrollV;			updateScroll();		}												/**		 * Initiates output window		 */		private static function init():void {							root.addEventListener(Event.ADDED, onAdded);			function onAdded(event:Event):void {				bringToFront();						}			if (root.stage.stageHeight - 10 < height) height = root.stage.stageHeight - 10;			// container			container = new Sprite()			drawBgd();			container.x = root.stage.stageWidth - container.width - 5;			container.y = 5;			root.addChild(container);			var desc:TextField = new TextField();			var tf:TextFormat = new TextFormat(windowFontName, 11, windowFontColor);			desc.x = 10;			desc.y = 6;			desc.selectable = false;			desc.mouseEnabled = false;			desc.defaultTextFormat = tf;			desc.text = windowName;			container.addChild(desc);			// main text field			txt = new TextField();			txt.background = true;			txt.backgroundColor = 0xffffff;			txt.wordWrap = true;			txt.width = width - txtSideMargin * 2 - scrollerBarWidth;			txt.height = height - txtTopMargin - txtBottomMargin;			txt.x = txtSideMargin;			txt.y = txtTopMargin;			tf = new TextFormat(fontName, fontSize);			txt.defaultTextFormat = tf;			txt.addEventListener(Event.SCROLL, updateScroll);			container.addChild(txt);			// scroller			scrollerBar = new Sprite();			drawScroller();			scrollerBar.x = txt.x + txt.width;			scrollerBar.y = txt.y;			container.addChild(scrollerBar);			// icons			closeIcon = createIcon('x');			closeIcon.x = width - closeIcon.width - 20;			closeIcon.y = 5;			closeIcon.addEventListener(MouseEvent.CLICK, closeWindow);			container.addChild(closeIcon);			clearIcon = createIcon('c');			clearIcon.x = width - clearIcon.width * 2 - 30;			clearIcon.y = 5;			clearIcon.addEventListener(MouseEvent.CLICK, clearOutput);			container.addChild(clearIcon);			//			root.stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyDown);			container.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDown);			root.stage.addEventListener(MouseEvent.MOUSE_UP, onMouseUp);			initiated = true;		}						/**		 * Draws window background		 * 		 * @param	width		 * @param	height		 */		private static function drawBgd():void {			var colors:Array = [0xf2f2f2, 0xc5c5c5, 0xeeeeee, 0xdddddd];			var matrix:Matrix = new Matrix();			matrix.createGradientBox(width, height, Math.PI / 2);			var ratio:Number = Math.abs(((height - 25) / height) * 255 - 255);			container.graphics.beginGradientFill(GradientType.LINEAR, colors, [1, 1, 1, 1], [0x02, ratio, ratio, 0xff], matrix);			container.graphics.drawRoundRect(0, 0, width, height, 10, 10);			container.graphics.endFill();		}						/**		 * Draws icon		 * 		 * @param	text		 * @return	Sprite		 */		private static function createIcon(text:String):Sprite {			var icon:Sprite = new Sprite();			var colors:Array = [0xffffff, 0x888888];			var matrix:Matrix = new Matrix();			matrix.createGradientBox(17, 16, Math.PI / 2);			icon.graphics.beginGradientFill(GradientType.LINEAR, colors, [1, 1], [0x00, 0xff], matrix);			icon.graphics.drawRoundRect(0, 0, 17, 16, 10, 10);			icon.graphics.endFill();			var txt:TextField = new TextField();			var tf:TextFormat = new TextFormat(windowFontName, 14, windowFontColor, true);			txt.defaultTextFormat = tf;			txt.text = text;			txt.width = icon.width;			txt.height = icon.height;			txt.selectable = false;			txt.mouseEnabled = false;			txt.autoSize = TextFieldAutoSize.CENTER;			txt.y = -4;			icon.addChild(txt);			return icon;		}						/**		 * Draws scroller bar		 */		private static function drawScroller():void {			var colors:Array = [0xdddddd, 0xc5c5c5];			var matrix:Matrix = new Matrix();			matrix.createGradientBox(scrollerBarWidth, txt.height, Math.PI / 2);			scrollerBar.graphics.beginGradientFill(GradientType.LINEAR, colors, [1, 1], [0x00, 0xff], matrix);			scrollerBar.graphics.drawRect(0, 0, scrollerBarWidth, txt.height);			scrollerBar.graphics.endFill();			var bevel:BevelFilter = new BevelFilter();			bevel.distance = 1;			bevel.blurX = bevel.blurY = 2;			scrollerBar.filters = [bevel];		}						// Event handlers						/**		 * Updates scroll bar position due to text position		 * 		 * @param	evt		 */		private static function updateScroll(evt:Event = null):void {			if (isBarDragged) return;			var scrollerDestHeight:Number;			if (txt.maxScrollV == 1) {				scrollerDestHeight = txt.height;				scrollerBar.alpha = .3;			}else{				scrollerDestHeight = txt.height * ((txt.numLines - txt.maxScrollV) / txt.numLines);				scrollerBar.alpha = 1;				if (scrollerDestHeight < scrollerBarMinHeight) scrollerDestHeight = scrollerBarMinHeight;			}//end if			scrollerBar.height = Math.round(scrollerDestHeight);			var perc:Number = (txt.scrollV - 1) / (txt.maxScrollV - 1 || 1);			scrollerBar.y = (txt.height - scrollerBar.height) * perc + txt.y;		}						/**		 * Updates text position in main text field due to scroller position		 * 		 * @param	evt		 */		private static function updateTextPos(evt:MouseEvent = null):void {			if (txt.maxScrollV == 1) return;			var perc:Number = (scrollerBar.y - txt.y) / (txt.height - scrollerBar.height);			txt.scrollV = Math.round((txt.maxScrollV - 1) * perc) + 1;		}						/**		 * Moves window to highest depth		 */		private static function bringToFront():void {			root.setChildIndex(container, root.numChildren - 1);		}						/**		 * Clears output		 * 		 * @param	evt		 */		private static function clearOutput(evt:MouseEvent):void {			txt.text = '';			updateScroll();		}						/**		 * Closes window		 * 		 * @param	evt		 */		private static function closeWindow(evt:MouseEvent):void {			container.visible = false;		}						/**		 * Keyboard event handler		 * Shows or hides window on F2 key		 * 		 * @param	evt		 */		private static function onKeyDown(evt:KeyboardEvent):void {			if (evt.keyCode == Keyboard.F2) {				container.visible = ! container.visible;				bringToFront();			}//end if		}						/**		 * Mouse down event handler		 * Handles window or scroll bar drag feature		 * 		 * @param	evt		 */		private static function onMouseDown(evt:MouseEvent):void {			if (evt.target == container && container.mouseY <= 25) {				container.startDrag();			}else if (evt.target == scrollerBar) {				var rect:Rectangle = new Rectangle(scrollerBar.x, txt.y, 0, txt.height - scrollerBar.height);				scrollerBar.startDrag(false, rect);				container.stage.addEventListener(MouseEvent.MOUSE_MOVE, updateTextPos);				isBarDragged = true;			}//end if			bringToFront();		}						/**		 * Mouse up event handler		 * Stops drag		 * 		 * @param	evt		 */		private static function onMouseUp(evt:MouseEvent):void {			container.stopDrag();			if (isBarDragged) {				container.stage.removeEventListener(MouseEvent.MOUSE_MOVE, updateTextPos);				updateTextPos();			}//end if			isBarDragged = false;		}			}	}