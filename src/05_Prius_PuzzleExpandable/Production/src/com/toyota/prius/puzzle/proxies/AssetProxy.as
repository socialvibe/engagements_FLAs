package com.toyota.prius.puzzle.proxies{	import cc.core.AbstractProxy;	import com.greensock.TimelineLite;	import away3d.loaders.Collada;	import away3d.containers.ObjectContainer3D;	import away3d.core.base.Object3D;	import away3d.core.math.Quaternion;	import away3d.materials.BitmapMaterial;	import away3d.loaders.data.MaterialData;	import away3d.loaders.utils.MaterialLibrary;	import away3d.containers.ObjectContainer3D;	import away3d.containers.Scene3D;		import com.toyota.prius.puzzle.models.Orientation;	//import com.toyota.events.PuzzleEvent;		import com.greensock.TweenLite;	import com.greensock.easing.Back;	import org.osflash.signals.Signal;		import flash.utils.setTimeout;	import flash.events.Event;	import flash.display.Bitmap;	//import flash.geom.Matrix3D;	//import flash.geom.Vector3D;	import com.toyota.prius.puzzle.utils.Vector3D;	public class AssetProxy extends Object	{		/**		 * @private		 * Default scale of the cube-pieces		 */		private static const DEFAULT_SCALE:Number = 25;		/**		 * @private		 * Embed		 */		[Embed(source='../../../../../../deploy/data/away3d/CubeTex_diffuse.png',mimeType="image/png")]		//[Embed(source='/CubeTex_diffuse.png',mimeType="image/png")]		//[Embed(source='http://media.socialvi.be/m/activities/toyota/prius_puzzle/data/away3d/CubeTex_diffuse.png',mimeType="image/png")]		private static const asset_texture:Class;				[Embed(source="../../../../../../deploy/data/away3d/side01.dae",mimeType="application/octet-stream")]		//[Embed(source="/side01.dae",mimeType="application/octet-stream")]		//[Embed(source='http://media.socialvi.be/m/activities/toyota/prius_puzzle/data/away3d/side01.dae',mimeType="image/png")]		private static const asset_corner1:Class;				[Embed(source="../../../../../../deploy/data/away3d/side02.dae",mimeType="application/octet-stream")]		//[Embed(source="/side02.dae",mimeType="application/octet-stream")]		//[Embed(source='http://media.socialvi.be/m/activities/toyota/prius_puzzle/data/away3d/side02.dae',mimeType="image/png")]		private static const asset_corner2:Class;		[Embed(source="../../../../../../deploy/data/away3d/side03.dae",mimeType="application/octet-stream")]		//[Embed(source="/side03.dae",mimeType="application/octet-stream")]		//[Embed(source='http://media.socialvi.be/m/activities/toyota/prius_puzzle/data/away3d/side03.dae',mimeType="image/png")]		private static const asset_corner3:Class;		[Embed(source="../../../../../../deploy/data/away3d/side04.dae",mimeType="application/octet-stream")]		//[Embed(source="/side04.dae",mimeType="application/octet-stream")]		//[Embed(source='http://media.socialvi.be/m/activities/toyota/prius_puzzle/data/away3d/side04.dae',mimeType="image/png")]		private static const asset_corner4:Class;				[Embed(source="../../../../../../deploy/data/away3d/side05.dae",mimeType="application/octet-stream")]		//[Embed(source="/side05.dae",mimeType="application/octet-stream")]		//[Embed(source='http://media.socialvi.be/m/activities/toyota/prius_puzzle/data/away3d/side05.dae',mimeType="image/png")]		private static const asset_corner5:Class;				[Embed(source="../../../../../../deploy/data/away3d/side06.dae",mimeType="application/octet-stream")]		//[Embed(source="/side06.dae",mimeType="application/octet-stream")]		//[Embed(source='http://media.socialvi.be/m/activities/toyota/prius_puzzle/data/away3d/side06.dae',mimeType="image/png")]		private static const asset_corner6:Class;				[Embed(source="../../../../../../deploy/data/away3d/side07.dae",mimeType="application/octet-stream")]		//[Embed(source="/side07.dae",mimeType="application/octet-stream")]		//[Embed(source='http://media.socialvi.be/m/activities/toyota/prius_puzzle/data/away3d/side07.dae',mimeType="image/png")]		private static const asset_corner7:Class;				[Embed(source="../../../../../../deploy/data/away3d/side08.dae",mimeType="application/octet-stream")]		//[Embed(source="/side08.dae",mimeType="application/octet-stream")]		//[Embed(source='http://media.socialvi.be/m/activities/toyota/prius_puzzle/data/away3d/side01.dae',mimeType="image/png")]		private static const asset_corner8:Class;		private var _history		:Array;				/**		 * @private		 * Collection of all corners		 */		private var _corners		:Array;		/**		 * @private		 * Texture bitmap		 */		private var _texture		:Bitmap;		/**		 * @private		 * texture as material		 */		private var _material		:BitmapMaterial;		/**		 * @private		 * corners		 */		private var _corner1		:Object3D;		private var _corner2		:Object3D;		private var _corner3		:Object3D;		private var _corner4		:Object3D;		private var _corner5		:Object3D;		private var _corner6		:Object3D;		private var _corner7		:Object3D;		private var _corner8		:Object3D;		/**		 * @private		 * async incremental index		 */		private var async_index		:int 	= 0;		/**		 * @private		 * max index of async loading		 */		private var async_max		:int	= 8;						private var _completeSignal:Signal;		private var _solvedSignal:Signal;		/**		 * @constructor		 * Creates a new AssetProxy object		 */		public function AssetProxy()		{				//super();			_history = [];						_completeSignal = new Signal( String );			_solvedSignal 	= new Signal();		}		/**		 * Loads all assets (synchronous)		 */		public function load():void		{			// ignore if already complete.			//if(_corners && _corners.length==async_max){ dispatchEvent(new Event(Event.COMPLETE)); return; }			if (_corners && _corners.length == async_max) { _completeSignal.dispatch( "load" ); return;  };			_corners 	= [];			inject();		}		/**		 * Loads all assets (asynchronus)		 */		public function loadAsync():void		{			// ignore if already complete.			//if (_corners && _corners.length == async_max) { dispatchEvent(new Event(Event.COMPLETE)); return; }			if (_corners && _corners.length == async_max) { _completeSignal.dispatch( "load" ); return;  };			async_index = 0;			_corners 	= [];			injectAsync();		}		/**		 * Resets all corners		 */		public function resetObjects():void		{			if ( _rotateSideTween ) {				_rotateSideTween.kill();				_rotateSideTween.complete( false, true );			}						if(_corners && _corners.length==async_max)			{				var item:Object3D;				for (var i:int = 0; i < _corners.length; i++)				{					item = _corners[i];				}			}						_history = [];		}		/**		 * @private		 * Asynchronus injection of assets from Embed		 */		private function injectAsync():void		{						_texture 	= new asset_texture() as Bitmap;			_material 	= new BitmapMaterial(_texture.bitmapData,{smooth:true});			async_index++;						var asset_class:Class 	=	AssetProxy['asset_corner'+async_index] as Class;			var data:* 				= XML(new asset_class());			_corners.push(this['_corner' + async_index] = Collada.parse(data, { materials: { Phong:_material }} ).children[0] as Object3D);						if(async_index!=async_max)				setTimeout(injectAsync,10);			else			{				memorizeInitialStates();				_completeSignal.dispatch( "injectAsync" );			}		}		/**		 * @private		 * Synchronous injection of assets from Embed		 */		private function inject():void		{			_texture 	= new asset_texture() as Bitmap;			_material 	= new BitmapMaterial(_texture.bitmapData,{smooth:true});			_corner1 	= Collada.parse(XML(new asset_corner1()),{}).children[0] as Object3D;			_corner2 	= Collada.parse(XML(new asset_corner2()),{}).children[0] as Object3D;			_corner3 	= Collada.parse(XML(new asset_corner3()),{}).children[0] as Object3D;			_corner4 	= Collada.parse(XML(new asset_corner4()),{}).children[0] as Object3D;			_corner5 	= Collada.parse(XML(new asset_corner5()),{}).children[0] as Object3D;			_corner6 	= Collada.parse(XML(new asset_corner6()),{}).children[0] as Object3D;			_corner7 	= Collada.parse(XML(new asset_corner7()),{}).children[0] as Object3D;			_corner8 	= Collada.parse(XML(new asset_corner8()),{}).children[0] as Object3D;			_corners 	= [_corner1,_corner2,_corner3,_corner4,_corner5,_corner6,_corner7,_corner8];						memorizeInitialStates();						//dispatchEvent(new Event(Event.COMPLETE));			_completeSignal.dispatch( "inject" );		}				private function memorizeInitialStates():void		{			var corner:Object3D;			for (var i:int = 0; i < _corners.length; i++)			{				corner = _corners[i];				corner.extra = {orientation:getObjectOrientation(corner)};			}		}				/**		 *	Normalize all or a single corner. 		 *  		 *	@param obj Object3D	Corner to normalize		 */		private function normalize(obj:Object3D=null):void		{			if(obj)			{				obj.applyRotations();			}			else			for each (var object:Object3D in _corners)			{				object.applyRotations();			}		}		/**		 *	Retrieves the orientation in the cube formation for the specified object.		 *		 * 	@param object Object3D		 *	@return Orientation		 */		public function getObjectOrientation(object:Object3D):Orientation		{			var o:Object3D = object.clone();			o.centerPivot();						var options:Object = {};			if(o.x > 0) 			options.left 	= true;			else 					options.right 	= true;			if(o.y > 0) 			options.top 	= true;			else 					options.bottom 	= true;			if(o.z > 0) 			options.front 	= true;			else 					options.back 	= true;						var orientation:Orientation = new Orientation(options);			return orientation;		}				/**		 *	Returns all corners that match the requested side orientation.		 * 		 * 	@param side String Use Orientation#[SIDES]		 *	@return Array		 */		public function getObjectsAt(side:String):Array		{			var result		:Array = [];			var corner		:Object3D;			var orientation	:Orientation;			for (var i:int = 0; i < _corners.length; i++)			{				corner = _corners[i];				orientation = getObjectOrientation(corner);				if(orientation[side]==true)				{					result.push(corner);				}			}			return result;		}				/**		 *	Rotates a <code>side</code> either counter- or clockwise on the specified time.		 *  If <code>time</code> is more than 0, onCompleteFunc will not be executed.		 * 		 * 	@param side String		 *	@param clockwise Boolean		 *	@param time Number		 *	@param onCompleteFunc Function		 */		private var _rotateSideTween:TimelineLite;		private var num:uint = 0;				public function rotateSide(side:String, clockwise:Boolean, time:Number=.4, onCompleteFunc:Function=null, history:Boolean=true):void		{				if ( history ) addToHistory( { side:side, clockwise:clockwise, time:time } );											var objects:Array = getObjectsAt(side);			var object:Object3D;						if ( _rotateSideTween ) _rotateSideTween.complete( false, true );						var tweenArr:Array = new Array();						var v:Vector3D;						for (var i:int = 0; i < objects.length; i++)			{				object = objects[i];				normalize(object);				//object.applyRotations();				v = new Vector3D();								switch (side)				{					case Orientation.LEFT: 		v.x = (clockwise)?-90: 90; break;					case Orientation.RIGHT: 	v.x = (clockwise)? 90:-90; break;										case Orientation.TOP: 		v.y = (clockwise)?-90: 90; break;					case Orientation.BOTTOM: 	v.y = (clockwise)? 90:-90; break;					                            					case Orientation.FRONT: 	v.z = (clockwise)?-90: 90; break;					case Orientation.BACK: 		v.z = (clockwise)? 90:-90; break;				}								if( time == 0 )				{					object.rotationX = object.rotationX+v.x;					object.rotationY = object.rotationY+v.y;					object.rotationZ = object.rotationZ+v.z;				}				else				{					try					{						tweenArr.push( new TweenLite( object, time, { rotationX:object.rotationX + v.x, rotationY:object.rotationY + v.y, rotationZ:object.rotationZ + v.z, ease:Back.easeOut, easeParams:[ .8 ] } ) );											}					catch(e:Error)					{						trace( "error" );						//log('error!');					}				}			}						if(time > 0)			{				_rotateSideTween = new TimelineLite( { onComplete:onRotationComplete } );				_rotateSideTween.appendMultiple( tweenArr );							//TweenLite.delayedCall(time + .05, onRotationComplete);				if (onCompleteFunc != null) TweenLite.delayedCall(time + .1, onCompleteFunc);			}			else			{				onRotationComplete();				if (onCompleteFunc != null) onCompleteFunc();			}		}			private function addToHistory( ob:Object ):void		{			var lastOb:Object = _history[ _history.length - 1 ];						if ( lastOb && lastOb.side == ob.side && lastOb.clockwise != ob.clockwise )			{				_history.pop();			}			else			{				_history.push( ob );			}		}				public function rotateSideWithAngle(side:String,angle:Number):void		{			var objects:Array = getObjectsAt(side);			var object:Object3D;			var v:Vector3D;			for (var i:int = 0; i < objects.length; i++)			{				object = objects[i];				normalize(object);				v = new Vector3D();				switch (side)				{					case Orientation.LEFT: 		v.x = angle; break;					case Orientation.RIGHT: 	v.x = angle; break;										case Orientation.TOP: 		v.y = angle; break;					case Orientation.BOTTOM: 	v.y = angle; break;										case Orientation.FRONT: 	v.z = angle; break;					case Orientation.BACK: 		v.z = angle; break;				}				object.rotationX = object.rotationX+v.x;				object.rotationY = object.rotationY+v.y;				object.rotationZ = object.rotationZ+v.z;			}		}				private function onRotationComplete():void		{			if(solved==true)			{				//dispatchEvent(new PuzzleEvent(PuzzleEvent.SOLVED))				_solvedSignal.dispatch();			}		}				public function get solved():Boolean		{			var corners		:Array;			var numFront	:uint = 0;			var numBack		:uint = 0;			var numLeft		:uint = 0;			var numRight	:uint = 0;			var numTop		:uint = 0;			var numBottom	:uint = 0;			var numWithFour	:uint = 0;						for each (var side:String in Orientation.SIDES)			{		   	 	numFront	= 0;			    numBack		= 0;			    numLeft		= 0;			    numRight	= 0;			    numTop		= 0;			    numBottom	= 0;				corners = getObjectsAt(side);								for each (var corner:Object3D in corners)				{					if(corner.extra.orientation.front) 	numFront++;					if(corner.extra.orientation.back) 	numBack++;					if(corner.extra.orientation.left)	numLeft++;					if(corner.extra.orientation.right) 	numRight++;					if(corner.extra.orientation.top) 	numTop++;					if(corner.extra.orientation.bottom) numBottom++;				}				switch(4)				{					case numFront   :					case numBack	:					case numLeft	:					case numRight   :					case numTop	    :					case numBottom  :						numWithFour++;				}			}						if(numWithFour==6) return true;			return false;		}				/**		 * Texture bitmap		 */		public function get texture():Bitmap		{			return _texture;		}		/**		 * Corner 1		 */		public function get corner1():Object3D		{			return _corner1;		}		/**		 * Corner 2		 */		public function get corner2():Object3D		{			return _corner2;		}        /**         * Corner 3         */		public function get corner3():Object3D		{			return _corner3;		}        /**         * Corner 4         */		public function get corner4():Object3D		{			return _corner4;		}        /**         * Corner 5         */		public function get corner5():Object3D		{			return _corner5;		}        /**         * Corner 6         */		public function get corner6():Object3D		{			return _corner6;		}        /**         * Corner 7         */		public function get corner7():Object3D		{			return _corner7;		}        /**         * Corner 8         */		public function get corner8():Object3D		{			return _corner8;		}		/**		 * All corners		 */		public function get corners():Array		{			return _corners;		}				/**		 * History array		 */		public function get history():Array		{			return _history;		}				/**		 * History array		 */		public function set history(value:Array):void		{			_history = value;		}						public function get completeSignal():Signal { return _completeSignal;  };		public function get solvedSignal():Signal { return _solvedSignal;  };		// ---------------------------------------------------------------------------------			}}