package com.toyota.prius.puzzle.views{	import com.toyota.prius.puzzle.PuzzleMain;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.geom.*	import flash.display.SpreadMethod;	import flash.display.GradientType;		import away3d.containers.View3D;	import away3d.containers.Scene3D;	import away3d.core.base.Object3D;	import away3d.events.MouseEvent3D;	import away3d.cameras.HoverCamera3D;	import away3d.primitives.WireSphere;	import away3d.primitives.Plane;	import away3d.primitives.Sphere;	import away3d.containers.ObjectContainer3D;	import away3d.cameras.Camera3D;	import org.osflash.signals.Signal;	import com.greensock.TweenLite;	import com.greensock.TweenMax;	import com.greensock.easing.Quad;		import com.toyota.prius.puzzle.proxies.AssetProxy;	import com.toyota.prius.puzzle.proxies.OutroCubeProxy;	import com.toyota.prius.puzzle.models.Orientation;	import com.toyota.prius.puzzle.elements.Button;	import com.toyota.prius.puzzle.views.PuzzleState;		//import com.toyota.events.PuzzleEvent;		import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;	import flash.geom.Point;	//import flash.geom.Vector3D;	import flash.filters.DropShadowFilter;	import com.socialvibe.engagement.api.*;			public class Away3DView extends MovieClip	{			private const DEBUG				:Boolean = false;		private const CAM_DISTANCE		:Number = 20;//20		private const CAM_PAN_ANGLE		:Number = 45;		private const CAM_TILT_ANGLE	:Number = 5;		private const CAM_ZOOM			:Number = 30;		private const CENTER_X			:uint = 485;		private const CENTER_Y			:uint = 190;				private const PAN_SPEED			:Number = .4;		private const TILT_SPEED		:Number = .8;		private const MIN_ANGLE			:Number = 30;				private const CUBE_SHADOW		:DropShadowFilter = new DropShadowFilter(45, -15, 0x000000, 0.1, 10, 10, 1, 3);				/*private const IDLE				:String 	= "idle";		private const INTRO_SPIN		:String 	= "intro_spin";		private const READY				:String 	= "ready";		private const PLAY				:String 	= "play";		private const REPLAY			:String 	= "replay";		private const SOLVED			:String 	= "solved";		private const OUTRO				:String 	= "outro";		private const OUTRO_DONE		:String 	= "outro_done";		*/		private var _state				:String;				private var _asset				:AssetProxy;				private var _view				:View3D;		private var _camera				:HoverCamera3D;		private var _scene				:Scene3D;		private var _background			:Sprite;				private var _mouseStart			:Point;		private var _mouseSide			:Orientation;		private var _mouse				:Point;		//private var _cameraStart		:Vector3D;				private var _currentCorner		:Object3D;				private var _possibleRotation	:Orientation;				private var _isRotating			:Boolean;		private var _hadMouseListener	:Boolean;		private var _hadBgMouseListener	:Boolean;		private var _introSpinSpeed		:Number;				//navigation variables		private var _move:Boolean = false;				private var _lastPanAngle:Number;		private var _lastTiltAngle:Number;		private var _lastMouseX:Number;		private var _lastMouseY:Number;				private var _ready:Signal;		private var _solved:Signal;		private var _clickthru:Signal;				public var _api:SocialVibeProxy = new SocialVibeProxy();						public function Away3DView( main:PuzzleMain )		{				_ready 		= new Signal();			_solved 	= new Signal();			_clickthru 	= new Signal();						main.replay.add( onReplay );						if (stage) init();			else addEventListener(Event.ADDED_TO_STAGE, init);		}				private function init(e:Event = null):void 		{			removeEventListener(Event.ADDED_TO_STAGE, init);			addEventListener(Event.REMOVED_FROM_STAGE, 	onRemovedFromStage);						_state 				= PuzzleState.IDLE;			_hadMouseListener 	= false;			_hadBgMouseListener = false;			initEngine();			initAssets();						initBG();						//addChild(_background);			addChild(_view);		}				private function onRemovedFromStage(e:Event = null):void 		{			trace( this, "onRemovedFromStage!!!!!!! ");			removeEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);					removeListeners( true );			removeTweens();			removeCube();			removeOutroCube();						stopRendering();		}				public function stopCube():void		{			removeListeners( true );			removeTweens();			stopRendering();						TweenMax.killAll();		}				// ***********************************************************		// INIT ENGINE		// ***********************************************************		private function initEngine():void		{			_scene			= new Scene3D(/*{rotationY:180}*/);			//_camera = new TargetCamera3D( { x:CAMERA_DISTANCE, y:CAMERA_DISTANCE, z:CAMERA_DISTANCE, zoom:30 } );			//camera = new HoverCamera3D({zoom:10, focus:100, distance:2000, yfactor:1});			_camera = new HoverCamera3D();			_camera.distance 	= CAM_DISTANCE;			_camera.yfactor 	= 1;			_camera.zoom 		= CAM_ZOOM;			_camera.panAngle 	= CAM_PAN_ANGLE - 180;// 45;			_camera.tiltAngle 	= CAM_TILT_ANGLE;			_camera.minTiltAngle = -45;			_camera.maxTiltAngle = 45;			_camera.hover(true);						_view			= new View3D( { scene:_scene, x:CENTER_X, y:CENTER_Y, camera:_camera } );			//_view.filters = [CUBE_SHADOW];					}				private function initBG():void		{			/*var matr:Matrix = new Matrix();			matr.createGradientBox(880, 880, 0, 45, -200);						_background	= new Sprite();			_background.graphics.beginGradientFill(GradientType.RADIAL, [0xFFFFFF, 0xC7DEE5], [1, 1], [0, 255], matr, SpreadMethod.PAD);        			_background.graphics.drawRect(0, 0, 970, 418);			_background.graphics.endFill();						bgMousePos = { };			_background.addEventListener( MouseEvent.MOUSE_DOWN, 	onBgDown );			_background.addEventListener( MouseEvent.MOUSE_UP, 		onBgUp );			_background.buttonMode = true;*/		}				private function removeBG():void		{			/*TweenLite.killTweensOf( _background );			_background.alpha = 0;*/			/*_background.alpha = 1;			this.removeChild( _background );			*/		}				private function showBG():void		{			/*TweenLite.killTweensOf( _background );			if ( _background.parent && _background.alpha == 1 ) return;						if ( !_background.parent )			{				initBG();				addChildAt(_background, 0 );				_background.alpha = 0;			}						TweenLite.to( _background, .3, { alpha:1 } );*/		}				// ***********************************************************		// INIT ASSETS		// ***********************************************************		private function initAssets():void		{			_asset	= new AssetProxy();// getProxy('asset') as AssetProxy;						_asset.solvedSignal.add( onPuzzleSolve );			_asset.completeSignal.add( onCompleteSignal );			_asset.loadAsync();		}						private function onCompleteSignal( str:String ):void		{			trace(this, "onCompleteSignal : " + str);						switch ( str )			{				case "injectAsync":					_asset.load();					break;									case "inject":									break;									case "load":					populate();					break;			}		}				// ***********************************************************		// POPULATE		// ***********************************************************		private function populate():void		{			reset();			startRendering();		}				// ***********************************************************				private function addCube():void		{			// add all objects to the scene			var object:Object3D;			for (var i:int = 0; i < _asset.corners.length; i++)			{				object = _asset.corners[i] as Object3D;				if ( _state == PuzzleState.IDLE ) _scene.addChild(object);				else if ( _state == PuzzleState.REPLAY ) object.visible = true;			}		}				private function removeCube():void		{			// add all objects to the scene			var object:Object3D;			var len:uint = _asset.corners.length - 1;						for (var i:int = len; i >= 0; i--)			{				object = _asset.corners[i] as Object3D;				_scene.removeChild( object );			}		}				// ***********************************************************		// RESET VARS		// ***********************************************************		private function reset():void		{				if ( DEBUG )			{				_state = PuzzleState.READY;				_ready.dispatch();			}						_isRotating			= false;			_introSpinSpeed		= 10;						// reset camera to movement start pos			_mouseStart = new Point(stage.mouseX, stage.mouseY);						_camera.panAngle 	= CAM_PAN_ANGLE - 180;			_camera.tiltAngle 	= CAM_TILT_ANGLE;			_camera.hover( true );						// reset all objects			_asset.resetObjects();			addCube();						_state			= PuzzleState.INTRO_SPIN;		}				// ***********************************************************		// START GAMES		// ***********************************************************		public function startGame():void		{			trace(this, "startGame : " );			_state = PuzzleState.PLAY;			initListeners();		}						// ***********************************************************		// INIT LISTENERS		// ***********************************************************		private function initListeners():void		{			if ( _state != PuzzleState.PLAY ) return;						_hadMouseListener 	= true;			_hadBgMouseListener = true;						// add Listeners to all objects			var object:Object3D;			for (var i:int = 0; i < _asset.corners.length; i++)			{				object = _asset.corners[i] as Object3D;				object.useHandCursor = true;				if( !object.hasEventListener( MouseEvent3D.MOUSE_DOWN ) ) object.addEventListener(MouseEvent3D.MOUSE_DOWN, onCornerDown);			}						//if( !_background.hasEventListener(MouseEvent.MOUSE_DOWN ) ) _background.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDownHandler);					}				public function removeListeners( all:Boolean=false ):void		{			_hadMouseListener 	= false;						var object:Object3D;			for (var i:int = 0; i < _asset.corners.length; i++)			{				object = _asset.corners[i] as Object3D;				object.useHandCursor = false;				object.removeEventListener(MouseEvent3D.MOUSE_DOWN, onCornerDown);			}						//_background.removeEventListener(MouseEvent.MOUSE_DOWN, onMouseDownHandler);						stage.removeEventListener(Event.MOUSE_LEAVE, 	onMouseUpHandler);   			stage.removeEventListener(MouseEvent.MOUSE_UP, 	onMouseUpHandler);			stage.removeEventListener(MouseEvent.MOUSE_UP, 	onCornerUp);						if ( all )			{				_hadBgMouseListener = false;								_background.removeEventListener( MouseEvent.MOUSE_DOWN, 	onBgDown );				_background.removeEventListener( MouseEvent.MOUSE_UP, 		onBgUp );			}		}				// ***********************************************************		// HINT		// ***********************************************************		public function onHintStart( solve:Boolean=false ):void		{			removeListeners();			_hadBgMouseListener = !solve;		}				public function onHintDone():void		{			if ( _state != PuzzleState.PLAY ) return;						initListeners();		}				// ***********************************************************		// START/STOP RENDER 		// ***********************************************************		//TODO		private function desert():void		{			// stop render if view is deserted.			stopRendering();		}				private function startRendering():void		{			if( !hasEventListener( Event.ENTER_FRAME ) ) addEventListener(Event.ENTER_FRAME, renderAway3DScene);		}				private function stopRendering():void		{			removeEventListener(Event.ENTER_FRAME, renderAway3DScene);		}				private function renderAway3DScene(e:Event=null):void		{			switch ( _state )			{				case PuzzleState.INTRO_SPIN:					updateCamAngle();					break;								case PuzzleState.PLAY:					if ( _move ) updateCamAngle();					else 		 camSnapTo();					break;								case PuzzleState.SOLVED:					return;					break;			}						if ( _state == PuzzleState.INTRO_SPIN || _state == PuzzleState.PLAY || _state == PuzzleState.READY )			{				_camera.hover();			}						_view.render();						if ( _state == PuzzleState.OUTRO_DONE ) stopRendering();		}				// ***********************************************************		// CAMERA MOVE		// ***********************************************************		private function introSpinDone():void		{			TweenLite.killDelayedCallsTo( introSpinDone );			_ready.dispatch();		}				private function updateCamAngle():void		{				if ( _state == PuzzleState.INTRO_SPIN )			{				_camera.panAngle -= _introSpinSpeed;				_introSpinSpeed *= .98;								// TILT				var curTilt:Number 	= _camera.tiltAngle;				if ( mathAbs( curTilt ) < MIN_ANGLE-.1  ) 				{					var targetTilt:Number 	= curTilt > 0 ? MIN_ANGLE : -MIN_ANGLE;					_camera.tiltAngle += ( targetTilt - curTilt ) * .1;				}								// PAN				if ( _camera.panAngle == CAM_PAN_ANGLE || _camera.panAngle <= CAM_PAN_ANGLE - 360 ) 				{					_state = PuzzleState.READY;					TweenLite.delayedCall( 1.5, introSpinDone );				}			} 			else if ( _state == PuzzleState.OUTRO )			{				_camera.panAngle -= _introSpinSpeed;				_introSpinSpeed *= 1.1;			}			else 			{				_camera.panAngle 	= PAN_SPEED 	* (stage.mouseX - _lastMouseX) + _lastPanAngle;				_camera.tiltAngle 	= TILT_SPEED * (stage.mouseY - _lastMouseY) + _lastTiltAngle;			}		}				private function camSnapTo():void		{				var curTilt:Number 	= _camera.tiltAngle;			var curPan:Number 	= _camera.panAngle;						var targetTilt:Number 	= 0;			var targetPan:Number 	= 0;						// SNAP TILT			if ( mathAbs( curTilt ) < MIN_ANGLE-.1  ) 			{				targetTilt 	= curTilt > 0 ? MIN_ANGLE : -MIN_ANGLE;				_camera.tiltAngle += ( targetTilt - curTilt ) * .3;			}						// SNAP PAN			var panOff:Number = curPan%90;			var dir:Number = curPan < 0 ? -1 : 1;						if( Math.abs( panOff ) < MIN_ANGLE-.1 || Math.abs( panOff ) > 90-MIN_ANGLE+.1 )			{				targetPan = Math.abs( panOff ) < MIN_ANGLE ? MIN_ANGLE * dir - panOff  : 90 * dir - panOff - MIN_ANGLE * dir;				if ( targetPan < .3 ) _camera.panAngle += targetPan;				else _camera.panAngle += targetPan * .3;			}		}						private function onMouseDownHandler(e:MouseEvent=null):void		{			trace(this, "bg onMouseDownHandler : ");			_move = true;						_lastPanAngle 	= _camera.panAngle;			_lastTiltAngle 	= _camera.tiltAngle;						_lastMouseX 	= stage.mouseX;			_lastMouseY 	= stage.mouseY;						stage.addEventListener(Event.MOUSE_LEAVE, 	onMouseUpHandler);			stage.addEventListener(MouseEvent.MOUSE_UP, onMouseUpHandler);		}				private function onMouseUpHandler(e:MouseEvent):void		{			_move = false;						_lastMouseX 	= stage.mouseX;			_lastMouseY 	= stage.mouseY;						stage.removeEventListener(Event.MOUSE_LEAVE, 	onMouseUpHandler);   			stage.removeEventListener(MouseEvent.MOUSE_UP, 	onMouseUpHandler);						camSnapTo();		}						// ***********************************************************		// ROTATE CUBE		// ***********************************************************				private function onCornerDown(e:MouseEvent3D):void		{			/*if ( _isRotating ) return;*/			//trace(this, 'corner: press: ' + e.object);						stage.addEventListener(MouseEvent.MOUSE_UP, 	onCornerUp);			_currentCorner = e.object;						if (!_mouseStart) _mouseStart = new Point();						_mouseStart.x = mouseX;			_mouseStart.y = mouseY;						var sceneX:Number = e.sceneX * 100;			var sceneY:Number = e.sceneY * 100;			var sceneZ:Number = e.sceneZ * 100;						var options:Object = {};			var absX:Number = (sceneX ^ (sceneX >> 31)) - (sceneX >> 31);			var absY:Number = (sceneY ^ (sceneY >> 31)) - (sceneY >> 31);			var absZ:Number = (sceneZ ^ (sceneZ >> 31)) - (sceneZ >> 31);						if(absX > absY && absX > absZ)			{				if(e.sceneX > 0)	options.left 	= true;				else 				options.right 	= true;			}			else if(absY > absX && absY > absZ )			{				if(e.sceneY > 0)	options.top 	= true;				else 				options.bottom 	= true;			}			else			{				if(e.sceneZ > 0) 	options.front 	= true;				else 				options.back 	= true;			}						_mouseSide = new Orientation(options);			trace("mouseSide : " + _mouseSide);			_api.trackOtherInteraction('cube_click');						// check which orientation current corner has and rotate according to mouse movement.			_possibleRotation = _asset.getObjectOrientation(e.object);		}				private function onCornerUp(e:MouseEvent):void		{				stage.removeEventListener(MouseEvent.MOUSE_UP, 		onCornerUp);			//stage.removeEventListener(MouseEvent.MOUSE_MOVE, 	onCornerMove);						if ( _mouseStart.x == mouseX && _mouseStart.y == mouseY ) return;						if(!_mouse) _mouse = new Point(0,0);			_mouse.x	= mouseX;			_mouse.y	= mouseY;						var horizontal	:Number = _mouse.x - _mouseStart.x;			var vertical	:Number = _mouse.y - _mouseStart.y;			var behind		:Boolean = _camera.z > 0;						//trace( this, "_possibleRotation : " + _possibleRotation);						//--			var params:Array = Orientation.getRotation( _mouseSide, _possibleRotation, horizontal, vertical, {x:_camera.x, y:_camera.y, z:_camera.z } );			//--			//trace(this, "params : " + params );						if ( params )			{				_isRotating = true;				_asset.rotateSide( params[0], params[1], .5, onRotateComplete );			}						//EW.trackInteraction("MOVE");					}				private function onRotateComplete():void		{			_isRotating = false;		}				/*		private function onCornerMove(e:MouseEvent):void		{			if(!_mouse) _mouse = new Point(0,0);			_mouse.x	= mouseX;			_mouse.y	= mouseY;		}		*/				// ***********************************************************		// PUZZLE DONE		// ***********************************************************				private function onPuzzleSolve():void		{			trace(this, 'SOLVED! _state: ' + _state )						if ( _state == PuzzleState.REPLAY )			{				reset();				return;			}						if ( _state != PuzzleState.PLAY )			{				return;			}						_state = PuzzleState.SOLVED;			_solved.dispatch();						_introSpinSpeed = 4;						removeListeners();		}				// ***********************************************************		// REPLAY		// ***********************************************************		private function onReplay():void		{			trace( this, "/REPLAY/ _state:" + _state );						TweenLite.killTweensOf( _background );			removeListeners();						if ( _state == PuzzleState.OUTRO ) onCubeOutroDone();						if ( _state == PuzzleState.SOLVED || _state == PuzzleState.OUTRO || _state == PuzzleState.OUTRO_DONE )			{				_state = PuzzleState.REPLAY;				showBG();				reset();				startRendering();				return;			}						_state = PuzzleState.REPLAY;					}				// ***********************************************************		// OUTRO PUZZLE		// ***********************************************************				public function onAddOutroCube():void		{						_state = PuzzleState.OUTRO;						// remove cube			var object:Object3D;			for (var i:int = 0; i < _asset.corners.length; i++)			{				object = _asset.corners[i] as Object3D;				object.visible = false;			}						var delay:Number = 0;						// add simple cube			var cube:OutroCubeProxy = new OutroCubeProxy( delay );			cube.name = "outroCube";			cube.done.addOnce( onCubeOutroDone );			_scene.addChild( cube );						// hide bg			TweenLite.to( _background, .3, { alpha:0, onComplete:removeBG, delay:delay } );		}				private function removeOutroCube():void		{			var cube:OutroCubeProxy = _scene.getChildByName( "outroCube" ) as OutroCubeProxy;						if ( cube )			{				cube.clear();				_scene.removeChild( cube as Object3D );			}		}				private function onCubeOutroDone():void		{				_state = PuzzleState.OUTRO_DONE;			removeOutroCube();		}				// ***********************************************************		private function removeTweens():void		{			TweenLite.killTweensOf( _background );			TweenLite.killDelayedCallsTo( introSpinDone );				}				// ***********************************************************		private var bgMousePos:Object;				private function onBgDown( e:MouseEvent ):void		{			bgMousePos.x = mouseX;			bgMousePos.y = mouseY;						if ( _hadBgMouseListener ) onMouseDownHandler();		}				private function onBgUp( e:MouseEvent ):void		{			if ( bgMousePos.x == mouseX && bgMousePos.y == mouseY )			{				_clickthru.dispatch();			}		}						// ***********************************************************				private function mathAbs( num:Number ):Number		{			return num > 0 ? num : -num;		}				public function get asset()		:AssetProxy 	{ return _asset; };		public function get ready()		:Signal 		{ return _ready; };		public function get solved()	:Signal 		{ return _solved; };		public function get clickthru()	:Signal 		{ return _clickthru; };		public function get state()		:String 		{ return _state; };				/*		override protected function onStateEnter(e:StateEvent):void		{			super.onStateEnter(e);		}						override protected function onStateExit(e:StateEvent):void		{			super.onStateExit(e);		}		*/	}}