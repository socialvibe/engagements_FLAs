package com.intersect{	import flash.display.MovieClip;	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;		import com.greensock.TweenNano;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.events.MouseEvent;	import com.greensock.easing.Sine;	import flash.utils.setTimeout;	import flash.utils.clearTimeout;	import flash.net.URLRequest;	import flash.net.navigateToURL;		public dynamic class CokeWoe extends MovieClip	{		private var phrases:Array = new Array();		private var currPhrase:int = 0;		private var currWord:int = 0;				private var mX:Number;		private var mY:Number;				public var dropTime:Number = 0.5;		public var dropRotation:Number = 90;		public var dropDistance:Number = 300;		public var speakRotation:Number = 320;		public var speakTime:Number = 0.3				//pendulum physics		private var damping:Number = 0.92;		private var period:Number = 1.0;		private var initAngle:Number = 0;		private var time:Number = 0;		private var bCanInteract:Boolean = true;		private var mouse = new Object();				public var pend:MovieClip;		public var mouseInfluence:Number = 1 / 128;		public var maxSwing:Number = Math.PI / 8;				public var myWord:MovieClip;				private var shakeTimeout:uint;				public function pendulumTick(evt)		{			updateMouse();			//trace('function called')			var angle:Number = initAngle*2 * Math.cos(2 * Math.PI * time / period);			//trace("angle: "+int(toDegrees(angle))+",\ttime: "+time);			pend.rotation = toDegrees(angle);						time += 1 / stage.frameRate;			initAngle *= damping;		}				public function toDegrees(rad:Number):Number		{			return rad / Math.PI * 180;		}				public function inits()		{			trackMouth();						clearWords();						stage.addEventListener(Event.ENTER_FRAME, trackMouth);			//clickThru.addEventListener(MouseEvent.CLICK, onClickThru);			//cta.addEventListener(MouseEvent.CLICK, onClickThru);			//cta.addEventListener(MouseEvent.ROLL_OVER, onOverCTA);			//cta.addEventListener(MouseEvent.ROLL_OUT, onOutCTA);			//clickThru.buttonMode = true;			//cta.buttonMode = true;						shakeTimeout = setTimeout(stopAllShakes, 15000000);		}				public function stopAllShakes()		{			iterate(stopShakeOf,this);		}				public function startAllShakes()		{			iterate(startShakeOf, this);			clearTimeout(shakeTimeout);			shakeTimeout = setTimeout(stopAllShakes, 15000);		}				private function stopShakeOf(dispObj:DisplayObject)		{			if (dispObj is ShakyObject)			{				trace("stopping shake of: " + dispObj);				ShakyObject(dispObj).stopShake();			}		}		private function startShakeOf(dispObj:DisplayObject)		{			if (dispObj is ShakyObject)			{				trace("starting shake of: " + dispObj);				ShakyObject(dispObj).startShake();			}		}				private function iterate(task:Function,dispObjContainer:DisplayObjectContainer):void		{			for(var i:int = 0; i<dispObjContainer.numChildren; i++)			{				var dispObj:DisplayObject = dispObjContainer.getChildAt(i);								task(dispObj);								if(dispObj is DisplayObjectContainer)					this.iterate(task,dispObj as DisplayObjectContainer);			}		}				private function trackMouth(e:Event = null){			var mouthPosition = pemContainer.pem.mouthPosition;			var mPoint = new Point(mouthPosition.x, mouthPosition.y);			var mGlobalPoint = pemContainer.pem.localToGlobal(mPoint);						mouthLocation(mGlobalPoint.x, mGlobalPoint.y);		}				public function initInteraction()		{			pend = sign;			stage.addEventListener(Event.ENTER_FRAME, pendulumTick);						bCanInteract = true;					}		public function pendHit()		{			var vel:Number = Math.min(1, Math.abs(mouse.speedX) * mouseInfluence);			if (mouse.speedX < 0) vel *= -1;			vel *= maxSwing;//22.5 degrees						if ( Math.abs(vel) > Math.abs(initAngle) )			{				initAngle = vel;				time = period / 4;				bCanInteract = false;				setTimeout(allowInteraction, period*1000);			}		}				function updateMouse()		{			if (mouse.previousX)				mouse.speedX = mouseX - mouse.previousX;			mouse.previousX = mouseX;						if (bCanInteract && pend.hitTestPoint(mouseX, mouseY) )				pendHit();		}				public function allowInteraction()		{			bCanInteract = true;		}				public function onClickThru(evt)		{			var tag = stage.root.loaderInfo.parameters.clickTAG;			if (tag.substr(0,5) == "http:" || tag.substr(0,6) == "https:")				navigateToURL(new URLRequest(tag),"_blank");		}				/*public function onRollOverSign(evt) 		{			//sign.play();		}				public function onRollOutSign(evt) 		{			//sign.play();		}*/				/*public function onOverCTA(evt) 		{			cta.gotoAndPlay("on");			cta.curls.curl1.gotoAndPlay("on");			cta.curls.curl2.gotoAndPlay("on");			cta.curls.curl3.gotoAndPlay("on");			cta.curls.curl4.gotoAndPlay("on");		}				public function onOutCTA(evt) 		{			cta.gotoAndPlay("off");			cta.curls.curl1.gotoAndPlay("off");			cta.curls.curl2.gotoAndPlay("off");			cta.curls.curl3.gotoAndPlay("off");			cta.curls.curl4.gotoAndPlay("off");		}*/				public function mouthLocation(posX:Number, posY:Number) {			mX = posX;			mY = posY;		}				public function createPhrase(field1:TextField = null, field2:TextField = null, field3:TextField = null, field4:TextField = null)		{			var phrase:Array;						trace( "Starting New Phrase: #"+(phrases.length+1) );			trace("Adding Phrase Line: "+field1.text);			if (field1 != null)			{				phrase = extractWords( field1 );				field1.visible = false;			}			if (field2 != null)			{				//trace("Adding Phrase Line: "+field2.text);				phrase = phrase.concat( extractWords( field2 ) );				field2.visible = false;			}			if (field3 != null)			{				//trace("Adding Phrase Line: "+field3.text);				phrase = phrase.concat( extractWords( field3 ) );				field3.visible = false;			}			if (field4 != null)			{				//trace("Adding Phrase Line: "+field4.text);				phrase = phrase.concat( extractWords( field4 ) );				field4.visible = false;			}			phrases.push(phrase);		}				public function speak()		{			//var myWord:MovieClip;			var targetX:Number;			var targetY:Number;						//trace('speaking...')						if (currPhrase < phrases.length)			{				if (currWord < phrases[currPhrase].length)				{					myWord = phrases[currPhrase][currWord];					targetX = myWord.x;					targetY = myWord.y;										myWord.x = mX;					myWord.y = mY;					myWord.rotation = speakRotation;					myWord.visible = true;					TweenNano.to(myWord, speakTime, { x:targetX, y:targetY, rotation:0 } );					currWord++;					if (currWord >= phrases[currPhrase].length)					{						currWord = 0;						currPhrase++;					}				}			}						pemContainer.pem.speak();		}				public function clearWords(bAnim:Boolean = false)		{			var i:int;			var j:int;						if (bAnim)			{				for (i = 0; i < phrases.length; i++)					{					for (j = 0; j < phrases[i].length; j++)					{						if (phrases[i][j].visible)							TweenNano.to(phrases[i][j], dropTime, { delay: Math.random()/4, y:(stage.stageHeight + phrases[i][j].width + 10), rotation:(Math.random()-0.5)*dropRotation, ease:Sine.easeIn,onComplete:visibleOff, onCompleteParams:[phrases[i][j]] } );					}				}			}			else			{				for (i = 0; i < phrases.length; i++)						for (j = 0; j < phrases[i].length; j++)						phrases[i][j].visible = false;			}		}						private function visibleOff(m)		{			m.visible=false;		}		private function extractWords( tF:TextField ):Array		{			//trace('extracts!!')			var allWords:Array = new Array();			var charLoc:Array = scanTextChars(tF); 						var textFormat:TextFormat = tF.getTextFormat();			var textFormatr:TextFormat = tF.getTextFormat();						var newTF:TextField;			var newTFr:TextField;			var wordBlock:MovieClip;			var bNewWord:Boolean = true;						var testX:int = 0;			var testY:int = tF.height/2;						for(var i:int = 0; i < charLoc.length; i++)			{				if (bNewWord)				{					newTF = new TextField();					newTF.embedFonts = true;					newTF.text = tF.text.charAt(i);					newTF.setTextFormat(textFormat);					newTF.selectable = false;					newTF.autoSize = "left";					wordBlock = new MovieClip();					wordBlock.x = tF.x + charLoc[i];					wordBlock.y = tF.y;						wordBlock.addChild(newTF);					allWords.push(wordBlock);					words.addChild(wordBlock);					bNewWord = false;				}				else				{					if (tF.text.charAt(i) == " ")						bNewWord = true;					else {					if (tF.text.charCodeAt(i)==174)						{						newTFr = new TextField();						newTFr.embedFonts = true;						newTFr.text = tF.text.charAt(i);						textFormatr.size = 12;						newTFr.setTextFormat(textFormatr);						newTFr.selectable = false;						newTFr.x = 20 /////////////////////////////////;						newTFr.y = 4;						wordBlock.addChild(newTFr);						} else newTF.appendText( tF.text.charAt(i) );					}				}			}						return allWords;		}		private function scanTextChars( tF:TextField ):Array		{			var charLoc:Array = new Array();						var testX:int = 0;			var testY:int = tF.height/2;			var prevIndex:int = -1;			var testIndex:int;						for (var i:int = 0; i < tF.width; i++)			{								testIndex = tF.getCharIndexAtPoint(testX+i, testY);				if (testIndex != prevIndex && testIndex != -1)				{					//trace( "Char["+testIndex+"] found at x="+(testX+i) );					charLoc.push(testX+i);					prevIndex = testIndex;				}			}						return charLoc;		}	}}